### BUG_REPORT
Title: CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound.

Description:
When fitting with bounds, the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound.  This is because it internally maps the fitted parameter range into the interval [0,1].  The unit of least precision (ulp) between floating point numbers is much smaller near zero than near one.  Thus, fits have much better resolution near the lower bound (which is mapped to zero) than the upper bound (which is mapped to one).  I will attach a example program to demonstrate.


### FAILING_TEST
org.apache.commons.math3.optimization.direct.CMAESOptimizer.doOptimize()
org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter.MultivariateFunctionMappingAdapter(MultivariateFunction,double[],double[])
org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(int,FUNC,GoalType,double[])
org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter.boundedToUnbounded(double[])
org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter.unboundedToBounded(double[])
org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(int,FUNC,GoalType,double[])
org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer()
org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int)
org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.repair(double[])
org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.penalty(double[],double[])

### CODE_SNIPPETS

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.CMAESOptimizer.doOptimize()
------------------------------------------------------------------------------------------
@Override
    protected PointValuePair doOptimize() {
        checkParameters();
         // -------------------- Initialization --------------------------------
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
        final FitnessFunction fitfun = new FitnessFunction();
        final double[] guess = getStartPoint();
        // number of objective variables/problem dimension
        dimension = guess.length;
        initializeCMA(guess);
        iterations = 0;
        double bestValue = fitfun.value(guess);
        push(fitnessHistory, bestValue);
        PointValuePair optimum = new PointValuePair(getStartPoint(),
                isMinimize ? bestValue : -bestValue);
        PointValuePair lastResult = null;

        // -------------------- Generation Loop --------------------------------

        generationLoop:
        for (iterations = 1; iterations <= maxIterations; iterations++) {
            // Generate and evaluate lambda offspring
            final RealMatrix arz = randn1(dimension, lambda);
            final RealMatrix arx = zeros(dimension, lambda);
            final double[] fitness = new double[lambda];
            // generate random offspring
            for (int k = 0; k < lambda; k++) {
                RealMatrix arxk = null;
                for (int i = 0; i < checkFeasableCount + 1; i++) {
                    if (diagonalOnly <= 0) {
                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)
                    } else {
                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
                                         .scalarMultiply(sigma));
                    }
                    if (i >= checkFeasableCount ||
                        fitfun.isFeasible(arxk.getColumn(0))) {
                        break;
                    }
                    // regenerate random arguments for row
                    arz.setColumn(k, randn(dimension));
                }
                copyColumn(arxk, 0, arx, k);
                try {
                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
                } catch (TooManyEvaluationsException e) {
                    break generationLoop;
                }
            }
            // Sort by fitness and compute weighted mean into xmean
            final int[] arindex = sortedIndices(fitness);
            // Calculate new xmean, this is selection and recombination
            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
            xmean = bestArx.multiply(weights);
            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
            final RealMatrix zmean = bestArz.multiply(weights);
            final boolean hsig = updateEvolutionPaths(zmean, xold);
            if (diagonalOnly <= 0) {
                updateCovariance(hsig, bestArx, arz, arindex, xold);
            } else {
                updateCovarianceDiagonalOnly(hsig, bestArz);
            }
            // Adapt step size sigma - Eq. (5)
            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));
            final double bestFitness = fitness[arindex[0]];
            final double worstFitness = fitness[arindex[arindex.length - 1]];
            if (bestValue > bestFitness) {
                bestValue = bestFitness;
                lastResult = optimum;
                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),
                                             isMinimize ? bestFitness : -bestFitness);
                if (getConvergenceChecker() != null && lastResult != null &&
                    getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                    break generationLoop;
                }
            }
            // handle termination criteria
            // Break, if fitness is good enough
            if (stopFitness != 0 && bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                break generationLoop;
            }
            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
            final double[] pcCol = pc.getColumn(0);
            for (int i = 0; i < dimension; i++) {
                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                    break;
                }
                if (i >= dimension - 1) {
                    break generationLoop;
                }
            }
            for (int i = 0; i < dimension; i++) {
                if (sigma * sqrtDiagC[i] > stopTolUpX) {
                    break generationLoop;
                }
            }
            final double historyBest = min(fitnessHistory);
            final double historyWorst = max(fitnessHistory);
            if (iterations > 2 &&
                Math.max(historyWorst, worstFitness) -
                Math.min(historyBest, bestFitness) < stopTolFun) {
                break generationLoop;
            }
            if (iterations > fitnessHistory.length &&
                historyWorst-historyBest < stopTolHistFun) {
                break generationLoop;
            }
            // condition number of the covariance matrix exceeds 1e14
            if (max(diagD)/min(diagD) > 1e7) {
                break generationLoop;
            }
            // user defined termination
            if (getConvergenceChecker() != null) {
                final PointValuePair current
                    = new PointValuePair(bestArx.getColumn(0),
                                         isMinimize ? bestFitness : -bestFitness);
                if (lastResult != null &&
                    getConvergenceChecker().converged(iterations, current, lastResult)) {
                    break generationLoop;
                    }
                lastResult = current;
            }
            // Adjust step size in case of equal function values (flat fitness)
            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
                sigma = sigma * Math.exp(0.2 + cs / damps);
            }
            if (iterations > 2 && Math.max(historyWorst, bestFitness) -
                Math.min(historyBest, bestFitness) == 0) {
                sigma = sigma * Math.exp(0.2 + cs / damps);
            }
            // store best in history
            push(fitnessHistory,bestFitness);
            fitfun.setValueRange(worstFitness-bestFitness);
            if (generateStatistics) {
                statisticsSigmaHistory.add(sigma);
                statisticsFitnessHistory.add(bestFitness);
                statisticsMeanHistory.add(xmean.transpose());
                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
            }
        }
        return optimum;
    }

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter.MultivariateFunctionMappingAdapter(MultivariateFunction,double[],double[])
------------------------------------------------------------------------------------------
public MultivariateFunctionMappingAdapter(final MultivariateFunction bounded,
                                                  final double[] lower, final double[] upper) {

        // safety checks
        MathUtils.checkNotNull(lower);
        MathUtils.checkNotNull(upper);
        if (lower.length != upper.length) {
            throw new DimensionMismatchException(lower.length, upper.length);
        }
        for (int i = 0; i < lower.length; ++i) {
            // note the following test is written in such a way it also fails for NaN
            if (!(upper[i] >= lower[i])) {
                throw new NumberIsTooSmallException(upper[i], lower[i], true);
            }
        }

        this.bounded = bounded;
        this.mappers = new Mapper[lower.length];
        for (int i = 0; i < mappers.length; ++i) {
            if (Double.isInfinite(lower[i])) {
                if (Double.isInfinite(upper[i])) {
                    // element is unbounded, no transformation is needed
                    mappers[i] = new NoBoundsMapper();
                } else {
                    // element is simple-bounded on the upper side
                    mappers[i] = new UpperBoundMapper(upper[i]);
                }
            } else {
                if (Double.isInfinite(upper[i])) {
                    // element is simple-bounded on the lower side
                    mappers[i] = new LowerBoundMapper(lower[i]);
                } else {
                    // element is double-bounded
                    mappers[i] = new LowerUpperBoundMapper(lower[i], upper[i]);
                }
            }
        }

    }

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(int,FUNC,GoalType,double[])
------------------------------------------------------------------------------------------
@Override
    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,
                                   double[] startPoint) {
        return super.optimizeInternal(maxEval, f, goalType,
                                      new InitialGuess(startPoint));
    }

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter.boundedToUnbounded(double[])
------------------------------------------------------------------------------------------
public double[] boundedToUnbounded(double[] point) {

        // map bounded input point to unbounded point
        final double[] mapped = new double[mappers.length];
        for (int i = 0; i < mappers.length; ++i) {
            mapped[i] = mappers[i].boundedToUnbounded(point[i]);
        }

        return mapped;

    }

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter.unboundedToBounded(double[])
------------------------------------------------------------------------------------------
public double[] unboundedToBounded(double[] point) {

        // map unbounded input point to bounded point
        final double[] mapped = new double[mappers.length];
        for (int i = 0; i < mappers.length; ++i) {
            mapped[i] = mappers[i].unboundedToBounded(point[i]);
        }

        return mapped;

    }

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(int,FUNC,GoalType,double[])
------------------------------------------------------------------------------------------
@Override
    public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,
                                   double[] startPoint) {
        return super.optimizeInternal(maxEval, f, goalType,
                                      new InitialGuess(startPoint));
    }

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer()
------------------------------------------------------------------------------------------
@Deprecated
    public CMAESOptimizer() {
        this(0);
    }

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int)
------------------------------------------------------------------------------------------
@Deprecated
    public CMAESOptimizer() {
        this(0);
    }

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.repair(double[])
------------------------------------------------------------------------------------------
[NOT FOUND] Source file not found: C:\Users\user\Desktop\uni\mark\CODE_SNIPPETS\Math\src\main\java\org\apache\commons\math3\optimization\direct\CMAESOptimizer\FitnessFunction.java

------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.direct.CMAESOptimizer.FitnessFunction.penalty(double[],double[])
------------------------------------------------------------------------------------------
[NOT FOUND] Source file not found: C:\Users\user\Desktop\uni\mark\CODE_SNIPPETS\Math\src\main\java\org\apache\commons\math3\optimization\direct\CMAESOptimizer\FitnessFunction.java
