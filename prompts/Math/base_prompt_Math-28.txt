### BUG_REPORT
Title: Not expected UnboundedSolutionException

Description:
SimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables.
In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES_COUNT = 2 and that will give almost good result and then set it to 15 and you'll get a massive of unbounded exceptions.
First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result.
The problem itself is well tested by it's authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values.
What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem.
The problem is formulated as
min(1*t + 0*L) (for every r-th subject)
s.t.
-q(r) + QL >= 0
x(r)t - XL >= 0
L >= 0
where 
r = 1..R, 
L = 
{l(1), l(2), ..., l(R)}
 (vector of R rows and 1 column),
Q - coefficients matrix MxR
X - coefficients matrix NxR


### FAILING_TEST
org.apache.commons.math3.optimization.linear.SimplexSolver.getPivotRow(SimplexTableau,int)
org.apache.commons.math3.optimization.linear.SimplexSolver.solvePhase1(SimplexTableau)
org.apache.commons.math3.optimization.linear.UnboundedSolutionException.UnboundedSolutionException()
org.apache.commons.math3.exception.MaxCountExceededException.MaxCountExceededException(Localizable,Number,Object)
org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter.value(double[])


### CODE_SNIPPETS


------------------------------------------------------------------------------------------
Function: org.apache.commons.math3.optimization.linear.SimplexSolver.getPivotRow(SimplexTableau,int)
------------------------------------------------------------------------------------------
private Integer getPivotRow(SimplexTableau tableau, final int col) {
        // create a list of all the rows that tie for the lowest score in the minimum ratio test
        List<Integer> minRatioPositions = new ArrayList<Integer>();
        double minRatio = Double.MAX_VALUE;
        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
            final double entry = tableau.getEntry(i, col);

            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                final double ratio = rhs / entry;
                // check if the entry is strictly equal to the current min ratio
                // do not use a ulp/epsilon check
                final int cmp = Double.compare(ratio, minRatio);
                if (cmp == 0) {
                    minRatioPositions.add(i);
                } else if (cmp < 0) {
                    minRatio = ratio;
                    minRatioPositions = new ArrayList<Integer>();
                    minRatioPositions.add(i);
                }
            }
        }

        if (minRatioPositions.size() == 0) {
            return null;
        } else if (minRatioPositions.size() > 1) {
            // there's a degeneracy as indicated by a tie in the minimum ratio test

            // 1. check if there's an artificial variable that can be forced out of the basis
            if (tableau.getNumArtificialVariables() > 0) {
                for (Integer row : minRatioPositions) {
                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                        int column = i + tableau.getArtificialVariableOffset();
                        final double entry = tableau.getEntry(row, column);
                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
                            return row;
                        }
                    }
                }
            }

            // 2. apply Bland's rule to prevent cycling:
            //    take the row for which the corresponding basic variable has the smallest index
            //
            // see http://www.stanford.edu/class/msande310/blandrule.pdf
            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
            //
            // Additional heuristic: if we did not get a solution after half of maxIterations
            //                       revert to the simple case of just returning the top-most row
            // This heuristic is based on empirical data gathered while investigating MATH-828.
            if (getIterations() < getMaxIterations() / 2) {
                Integer minRow = null;
                int minIndex = tableau.getWidth();
                final int varStart = tableau.getNumObjectiveFunctions();
                final int varEnd = tableau.getWidth() - 1;
                for (Integer row : minRatioPositions) {
                    for (int i = varStart; i < varEnd && !row.equals(minRow); i++) {
                        final Integer basicRow = tableau.getBasicRow(i);
                        if (basicRow != null && basicRow.equals(row) && i < minIndex) {
                            minIndex = i;
                            minRow = row;
                        }
                    }
                }
                return minRow;
            }
        }
        return minRatioPositions.get(0);
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.math3.optimization.linear.SimplexSolver.solvePhase1(SimplexTableau)
------------------------------------------------------------------------------------------
protected void solvePhase1(final SimplexTableau tableau)
        throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {

        // make sure we're in Phase 1
        if (tableau.getNumArtificialVariables() == 0) {
            return;
        }

        while (!tableau.isOptimal()) {
            doIteration(tableau);
        }

        // if W is not zero then we have no feasible solution
        if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {
            throw new NoFeasibleSolutionException();
        }
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.math3.optimization.linear.UnboundedSolutionException.UnboundedSolutionException()
------------------------------------------------------------------------------------------
public UnboundedSolutionException() {
        super(LocalizedFormats.UNBOUNDED_SOLUTION);
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.math3.exception.MaxCountExceededException.MaxCountExceededException(Localizable,Number,Object)
------------------------------------------------------------------------------------------
public MaxCountExceededException(Number max) {
        this(LocalizedFormats.MAX_COUNT_EXCEEDED, max);
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.math3.optimization.direct.MultivariateFunctionMappingAdapter.value(double[])
------------------------------------------------------------------------------------------
public double value(double[] point) {
        return bounded.value(unboundedToBounded(point));
    }

------------------------------------------------------------------------------------------

