### BUG_REPORT
Title: StringEscapeUtils.escapeXML() can't process UTF-16 supplementary characters

Description:
Supplementary characters in UTF-16 are those whose code points are above 0xffff, that is, require more than 1 Java char to be encoded, as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/
Currently, StringEscapeUtils.escapeXML() isn't aware of this coding scheme and treats each char as one character, which is not always right.
A possible solution in class Entities would be:
    public void escape(Writer writer, String str) throws IOException {
        int len = str.length();
        for (int i = 0; i < len; i++) {
            int code = str.codePointAt;
            String entityName = this.entityName(code);
            if (entityName != null) 
{
                writer.write('&');
                writer.write(entityName);
                writer.write(';');
            }
 else if (code > 0x7F) 
{
                    writer.write("&#");
                    writer.write(code);
                    writer.write(';');
            }
 else 
{
                    writer.write((char) code);
            }

            if (code > 0xffff) 
{
                    i++;
            }
        }
    }
Besides fixing escapeXML(), this will also affect HTML escaping functions. I guess that's a good thing, but please remember I have only tested escapeXML().


### FAILING_TEST
org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(CharSequence,int,Writer)
org.apache.commons.lang3.text.translate.NumericEntityEscaper.translate(int,Writer)
org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequence,Writer)
org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequence)
org.apache.commons.lang3.text.StrBuilder.asWriter()


### CODE_SNIPPETS


------------------------------------------------------------------------------------------
Function: org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(CharSequence,int,Writer)
------------------------------------------------------------------------------------------
@Override
    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
        final int seqEnd = input.length();
        // Uses -2 to ensure there is something after the &#
        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
            int start = index + 2;
            boolean isHex = false;

            final char firstChar = input.charAt(start);
            if(firstChar == 'x' || firstChar == 'X') {
                start++;
                isHex = true;

                // Check there's more than just an x after the &#
                if(start == seqEnd) {
                    return 0;
                }
            }

            int end = start;
            // Note that this supports character codes without a ; on the end
            while(end < seqEnd && ( input.charAt(end) >= '0' && input.charAt(end) <= '9' ||
                                    input.charAt(end) >= 'a' && input.charAt(end) <= 'f' ||
                                    input.charAt(end) >= 'A' && input.charAt(end) <= 'F' ) )
            {
                end++;
            }

            final boolean semiNext = end != seqEnd && input.charAt(end) == ';';

            if(!semiNext) {
                if(isSet(OPTION.semiColonRequired)) {
                    return 0;
                } else
                if(isSet(OPTION.errorIfNoSemiColon)) {
                    throw new IllegalArgumentException("Semi-colon required at end of numeric entity");
                }
            }

            int entityValue;
            try {
                if(isHex) {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
                } else {
                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
                }
            } catch(final NumberFormatException nfe) {
                return 0;
            }

            if(entityValue > 0xFFFF) {
                final char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                out.write(entityValue);
            }

            return 2 + end - start + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
        }
        return 0;
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.lang3.text.translate.NumericEntityEscaper.translate(int,Writer)
------------------------------------------------------------------------------------------
@Override
    public boolean translate(final int codepoint, final Writer out) throws IOException {
        if(between) {
            if (codepoint < below || codepoint > above) {
                return false;
            }
        } else {
            if (codepoint >= below && codepoint <= above) {
                return false;
            }
        }

        out.write("&#");
        out.write(Integer.toString(codepoint, 10));
        out.write(';');
        return true;
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequence,Writer)
------------------------------------------------------------------------------------------
public abstract int translate(CharSequence input, int index, Writer out) throws IOException;

    /**
     * Helper for non-Writer usage. 
     * @param input CharSequence to be translated
     * @return String output of translation
     */
    public final String translate(final CharSequence input) {
        if (input == null) {
            return null;
        }
        try {
            final StringWriter writer = new StringWriter(input.length() * 2);
            translate(input, writer);
            return writer.toString();
        } catch (final IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequence)
------------------------------------------------------------------------------------------
public abstract int translate(CharSequence input, int index, Writer out) throws IOException;

    /**
     * Helper for non-Writer usage. 
     * @param input CharSequence to be translated
     * @return String output of translation
     */
    public final String translate(final CharSequence input) {
        if (input == null) {
            return null;
        }
        try {
            final StringWriter writer = new StringWriter(input.length() * 2);
            translate(input, writer);
            return writer.toString();
        } catch (final IOException ioe) {
            // this should never ever happen while writing to a StringWriter
            throw new RuntimeException(ioe);
        }
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.lang3.text.StrBuilder.asWriter()
------------------------------------------------------------------------------------------
public Writer asWriter() {
        return new StrBuilderWriter();
    }

------------------------------------------------------------------------------------------



### FAILURE_TRACE

------------------------------------------------------------------------------------------
Fail #1
Test: org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest#testSupplementaryUnescaping
Runtime: 1949141
------------------------------------------------------------------------------------------
junit.framework.ComparisonFailure: Failed to unescape numeric entities supplementary characters expected:<[ð°¢]> but was:<[à°¢]> at junit.framework.Assert.assertEquals(Assert.java:100) at junit.framework.TestCase.assertEquals(TestCase.java:261) at org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest.testSupplementaryUnescaping(NumericEntityUnescaperTest.java:33) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at junit.framework.TestCase.runTest(TestCase.java:176) at junit.framework.TestCase.runBare(TestCase.java:141) at junit.framework.TestResult$1.protect(TestResult.java:122) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.framework.TestResult.run(TestResult.java:125) at junit.framework.TestCase.run(TestCase.java:129) at junit.framework.TestSuite.runTest(TestSuite.java:252) at junit.framework.TestSuite.run(TestSuite.java:247) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at org.junit.runner.JUnitCore.run(JUnitCore.java:115) at com.gzoltar.internal.core.test.junit.JUnitTestTask.call(JUnitTestTask.java:57) at com.gzoltar.internal.core.test.junit.JUnitTestTask.call(JUnitTestTask.java:25) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.lang.Thread.run(Thread.java:834)
