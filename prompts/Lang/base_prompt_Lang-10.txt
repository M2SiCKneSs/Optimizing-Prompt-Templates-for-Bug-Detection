### BUG_REPORT
Title: FastDateParser does not handle white-space properly

Description:
The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters.
This means that FDP will parse dates that fail when parsed by SDP.


### FAILING_TEST
org.apache.commons.lang3.time.FastDateParser.getParsePattern()
org.apache.commons.lang3.time.FastDateParser.parse(String)
org.apache.commons.lang3.time.FastDateParser.escapeRegex(StringBuilder,String,boolean)
org.apache.commons.lang3.time.FastDateParser.parse(String,ParsePosition)
org.apache.commons.lang3.time.FastDateParser.equals(Object)


### CODE_SNIPPETS


------------------------------------------------------------------------------------------
Function: org.apache.commons.lang3.time.FastDateParser.getParsePattern()
------------------------------------------------------------------------------------------
Pattern getParsePattern() {
        return parsePattern;
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.lang3.time.FastDateParser.parse(String)
------------------------------------------------------------------------------------------
@Override
    public Date parse(final String source) throws ParseException {
        final Date date= parse(source, new ParsePosition(0));
        if(date==null) {
            // Add a note re supported date range
            if (locale.equals(JAPANESE_IMPERIAL)) {
                throw new ParseException(
                        "(The " +locale + " locale does not support dates before 1868 AD)\n" +
                                "Unparseable date: \""+source+"\" does not match "+parsePattern.pattern(), 0);
            }
            throw new ParseException("Unparseable date: \""+source+"\" does not match "+parsePattern.pattern(), 0);
        }
        return date;
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.lang3.time.FastDateParser.escapeRegex(StringBuilder,String,boolean)
------------------------------------------------------------------------------------------
private static StringBuilder escapeRegex(final StringBuilder regex, final String value, final boolean unquote) {
        regex.append("\\Q");
        for(int i= 0; i<value.length(); ++i) {
            char c= value.charAt(i);
            switch(c) {
            case '\'':
                if(unquote) {
                    if(++i==value.length()) {
                        return regex;
                    }
                    c= value.charAt(i);
                }
                break;
            case '\\':
                if(++i==value.length()) {
                    break;
                }                
                /*
                 * If we have found \E, we replace it with \E\\E\Q, i.e. we stop the quoting,
                 * quote the \ in \E, then restart the quoting.
                 * 
                 * Otherwise we just output the two characters.
                 * In each case the initial \ needs to be output and the final char is done at the end
                 */
                regex.append(c); // we always want the original \
                c = value.charAt(i); // Is it followed by E ?
                if (c == 'E') { // \E detected
                  regex.append("E\\\\E\\"); // see comment above
                  c = 'Q'; // appended below
                }
                break;
            }
            regex.append(c);
        }
        regex.append("\\E");
        return regex;
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.lang3.time.FastDateParser.parse(String,ParsePosition)
------------------------------------------------------------------------------------------
@Override
    public Date parse(final String source) throws ParseException {
        final Date date= parse(source, new ParsePosition(0));
        if(date==null) {
            // Add a note re supported date range
            if (locale.equals(JAPANESE_IMPERIAL)) {
                throw new ParseException(
                        "(The " +locale + " locale does not support dates before 1868 AD)\n" +
                                "Unparseable date: \""+source+"\" does not match "+parsePattern.pattern(), 0);
            }
            throw new ParseException("Unparseable date: \""+source+"\" does not match "+parsePattern.pattern(), 0);
        }
        return date;
    }

------------------------------------------------------------------------------------------

Function: org.apache.commons.lang3.time.FastDateParser.equals(Object)
------------------------------------------------------------------------------------------
@Override
    public boolean equals(final Object obj) {
        if (! (obj instanceof FastDateParser) ) {
            return false;
        }
        final FastDateParser other = (FastDateParser) obj;
        return pattern.equals(other.pattern)
            && timeZone.equals(other.timeZone)
            && locale.equals(other.locale);
    }

------------------------------------------------------------------------------------------



### FAILURE_TRACE

------------------------------------------------------------------------------------------
Fail #1
Test: org.apache.commons.lang3.time.FastDateFormat_ParserTest#testLANG_831
Runtime: 3859490
------------------------------------------------------------------------------------------
java.lang.AssertionError: Parsed dates should be equal expected:<null> but was:<Mon Mar 02 21:00:00 PST 1970> at org.junit.Assert.fail(Assert.java:88) at org.junit.Assert.failNotEquals(Assert.java:834) at org.junit.Assert.assertEquals(Assert.java:118) at org.apache.commons.lang3.time.FastDateParserTest.testSdfAndFdp(FastDateParserTest.java:382) at org.apache.commons.lang3.time.FastDateParserTest.testLANG_831(FastDateParserTest.java:342) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at org.junit.runner.JUnitCore.run(JUnitCore.java:115) at com.gzoltar.internal.core.test.junit.JUnitTestTask.call(JUnitTestTask.java:57) at com.gzoltar.internal.core.test.junit.JUnitTestTask.call(JUnitTestTask.java:25) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.lang.Thread.run(Thread.java:834)

------------------------------------------------------------------------------------------
Fail #2
Test: org.apache.commons.lang3.time.FastDateParserTest#testLANG_831
Runtime: 1353333
------------------------------------------------------------------------------------------
junit.framework.AssertionFailedError: Expected FDF failure
