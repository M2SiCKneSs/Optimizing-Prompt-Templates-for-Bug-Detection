### BUG_REPORT
Title: #126 Errors creating/parsing dates with specific time zones.

Description:
Consider the following test code using Joda 2.0
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import java.util.Set;
public class JodaDateTimeZoneTester {
private static DateTimeFormatter formatter = DateTimeFormat.forPattern("MM/dd/yyyy HH:mm:ss.SSS ZZZ");
private static int numTimeZonesTested = 0;
private static int numTimeZonesPassed = 0;
private static int numTimeZonesFailed = 0;
private static int numTimeZonesException = 0;

private static String convertDateTimeToFormattedString(DateTime dateTime) {
    return formatter.print(dateTime);
}

private static DateTime parseStringToDateTime(String formattedDateTime) {
    return formatter.parseDateTime(formattedDateTime);
}

private static void testDateTimeFormatter(DateTime dateTime, String timeZone) {
    numTimeZonesTested++;

    final String dateTimeZoneId = dateTime.getZone().getID();

    if (!timeZone.equals(dateTimeZoneId)) {
        numTimeZonesFailed++;
        System.out.println(timeZone + " failed to construct into the proper date time zone - constructed time zone = " + dateTimeZoneId);
        return;
    }
    try {
        DateTime convertedDateTime = parseStringToDateTime(convertDateTimeToFormattedString(dateTime));

        if (dateTime.equals(convertedDateTime)) {
            numTimeZonesPassed++;
            //System.out.println(dateTime.getZone().getID() + " passed.");
        } else {
            numTimeZonesFailed++;
            System.out.println("Formatter failed for time zone ID: " + dateTimeZoneId + "    converted it to: " + convertedDateTime.getZone().getID());
        }
    } catch (IllegalArgumentException iae) {
        numTimeZonesException++;
        System.out.println("Formatter threw exception for time zone id: " + dateTimeZoneId);
    }
}

public static void main(String[] args) {
    Set<String> timeZones = DateTimeZone.getAvailableIDs();

    for (String timeZone : timeZones) {
        testDateTimeFormatter(DateTime.now().withZone(DateTimeZone.forID(timeZone)), timeZone);
    }

    System.out.println();
    System.out.println("Number of Time Zones tested: " + numTimeZonesTested);
    System.out.println("Number passed:     " + numTimeZonesPassed);
    System.out.println("Number failed:     " + numTimeZonesFailed);
    System.out.println("Number exceptions: " + numTimeZonesException);
    System.out.println();
}

}
The results are out of 572 time zones 130 fail and 30 throw exceptions. 
The failures are the most interesting. When I query DateTimeZone to get its time zone ids I will get a time zone like America/Atka. When I take that id and create a date time with it its time zone id is America/Adak. It is like there are multiple list of time zones in Joda time and they are out of sync. 
Source code is attached.


### FAILING_TEST
org.joda.time.tz.ZoneInfoCompiler.compile(File,File[])
org.joda.time.format.DateTimeFormatterBuilder.printTo(StringBuffer,long,Chronology,int,DateTimeZone,Locale)
org.joda.time.format.DateTimeParserBucket.setZone(DateTimeZone)
org.joda.time.tz.ZoneInfoCompiler.printUsage()
org.joda.time.format.DateTimeFormatterBuilder.parseInto(DateTimeParserBucket,String,int)


### CODE_SNIPPETS


------------------------------------------------------------------------------------------
Function: org.joda.time.tz.ZoneInfoCompiler.compile(File,File[])
------------------------------------------------------------------------------------------
public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {
        if (sources != null) {
            for (int i=0; i<sources.length; i++) {
                BufferedReader in = new BufferedReader(new FileReader(sources[i]));
                parseDataFile(in);
                in.close();
            }
        }

        if (outputDir != null) {
            if (!outputDir.exists()) {
                if (!outputDir.mkdirs()) {
                    throw new IOException("Destination directory doesn't exist and cannot be created: " + outputDir);
                }
            }
            if (!outputDir.isDirectory()) {
                throw new IOException("Destination is not a directory: " + outputDir);
            }
        }

        Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();

        System.out.println("Writing zoneinfo files");
        for (int i=0; i<iZones.size(); i++) {
            Zone zone = iZones.get(i);
            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();
            zone.addToBuilder(builder, iRuleSets);
            final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);
            DateTimeZone tz = original;
            if (test(tz.getID(), tz)) {
                map.put(tz.getID(), tz);
                if (outputDir != null) {
                    if (ZoneInfoCompiler.verbose()) {
                        System.out.println("Writing " + tz.getID());
                    }
                    File file = new File(outputDir, tz.getID());
                    if (!file.getParentFile().exists()) {
                        file.getParentFile().mkdirs();
                    }
                    OutputStream out = new FileOutputStream(file);
                    try {
                        builder.writeTo(zone.iName, out);
                    } finally {
                        out.close();
                    }

                    // Test if it can be read back.
                    InputStream in = new FileInputStream(file);
                    DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());
                    in.close();

                    if (!original.equals(tz2)) {
                        System.out.println("*e* Error in " + tz.getID() +
                                           ": Didn't read properly from file");
                    }
                }
            }
        }

        for (int pass=0; pass<2; pass++) {
            for (int i=0; i<iLinks.size(); i += 2) {
                String id = iLinks.get(i);
                String alias = iLinks.get(i + 1);
                DateTimeZone tz = map.get(id);
                if (tz == null) {
                    if (pass > 0) {
                        System.out.println("Cannot find time zone '" + id +
                                           "' to link alias '" + alias + "' to");
                    }
                } else {
                    map.put(alias, tz);
                }
            }
        }

        if (outputDir != null) {
            System.out.println("Writing ZoneInfoMap");
            File file = new File(outputDir, "ZoneInfoMap");
            if (!file.getParentFile().exists()) {
                file.getParentFile().mkdirs();
            }

            OutputStream out = new FileOutputStream(file);
            DataOutputStream dout = new DataOutputStream(out);
            try {
                // Sort and filter out any duplicates that match case.
                Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);
                zimap.putAll(map);
                writeZoneInfoMap(dout, zimap);
            } finally {
                dout.close();
            }
        }

        return map;
    }

------------------------------------------------------------------------------------------

Function: org.joda.time.format.DateTimeFormatterBuilder.printTo(StringBuffer,long,Chronology,int,DateTimeZone,Locale)
------------------------------------------------------------------------------------------
public void printTo(
                StringBuffer buf, long instant, Chronology chrono,
                int displayOffset, DateTimeZone displayZone, Locale locale) {
            buf.append(iValue);
        }

------------------------------------------------------------------------------------------

Function: org.joda.time.format.DateTimeParserBucket.setZone(DateTimeZone)
------------------------------------------------------------------------------------------
public void setZone(DateTimeZone zone) {
        iSavedState = null;
        iZone = zone;
    }

------------------------------------------------------------------------------------------

Function: org.joda.time.tz.ZoneInfoCompiler.printUsage()
------------------------------------------------------------------------------------------
private static void printUsage() {
        System.out.println("Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>");
        System.out.println("where possible options include:");
        System.out.println("  -src <directory>    Specify where to read source files");
        System.out.println("  -dst <directory>    Specify where to write generated files");
        System.out.println("  -verbose            Output verbosely (default false)");
    }

------------------------------------------------------------------------------------------

Function: org.joda.time.format.DateTimeFormatterBuilder.parseInto(DateTimeParserBucket,String,int)
------------------------------------------------------------------------------------------
public int parseInto(DateTimeParserBucket bucket, String text, int position) {
            if (position >= text.length()) {
                return ~position;
            }

            char a = text.charAt(position);
            char b = iValue;

            if (a != b) {
                a = Character.toUpperCase(a);
                b = Character.toUpperCase(b);
                if (a != b) {
                    a = Character.toLowerCase(a);
                    b = Character.toLowerCase(b);
                    if (a != b) {
                        return ~position;
                    }
                }
            }

            return position + 1;
        }

------------------------------------------------------------------------------------------



### FAILURE_TRACE

------------------------------------------------------------------------------------------
Fail #1
Test: org.joda.time.TestPeriodType#testForFields4
Runtime: 1253523
------------------------------------------------------------------------------------------
junit.framework.AssertionFailedError: expected:<true> but was:<false> at junit.framework.Assert.fail(Assert.java:57) at junit.framework.Assert.failNotEquals(Assert.java:329) at junit.framework.Assert.assertEquals(Assert.java:78) at junit.framework.Assert.assertEquals(Assert.java:174) at junit.framework.Assert.assertEquals(Assert.java:181) at junit.framework.TestCase.assertEquals(TestCase.java:341) at org.joda.time.TestPeriodType.testForFields4(TestPeriodType.java:534) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at junit.framework.TestCase.runTest(TestCase.java:176) at junit.framework.TestCase.runBare(TestCase.java:141) at junit.framework.TestResult$1.protect(TestResult.java:122) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.framework.TestResult.run(TestResult.java:125) at junit.framework.TestCase.run(TestCase.java:129) at junit.framework.TestSuite.runTest(TestSuite.java:252) at junit.framework.TestSuite.run(TestSuite.java:247) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at org.junit.runner.JUnitCore.run(JUnitCore.java:115) at com.gzoltar.internal.core.test.junit.JUnitTestTask.call(JUnitTestTask.java:57) at com.gzoltar.internal.core.test.junit.JUnitTestTask.call(JUnitTestTask.java:25) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.lang.Thread.run(Thread.java:834)

------------------------------------------------------------------------------------------
Fail #2
Test: org.joda.time.format.TestDateTimeFormatterBuilder#test_printParseZoneDawsonCreek
Runtime: 6545907
------------------------------------------------------------------------------------------
java.lang.IllegalArgumentException: Invalid format: "2007-03-04 12:30 America/Dawson_Creek" is malformed at "_Creek" at org.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:866) at org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek(TestDateTimeFormatterBuilder.java:262) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at junit.framework.TestCase.runTest(TestCase.java:176) at junit.framework.TestCase.runBare(TestCase.java:141) at junit.framework.TestResult$1.protect(TestResult.java:122) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.framework.TestResult.run(TestResult.java:125) at junit.framework.TestCase.run(TestCase.java:129) at junit.framework.TestSuite.runTest(TestSuite.java:252) at junit.framework.TestSuite.run(TestSuite.java:247) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at org.junit.runner.JUnitCore.run(JUnitCore.java:115) at com.gzoltar.internal.core.test.junit.JUnitTestTask.call(JUnitTestTask.java:57) at com.gzoltar.internal.core.test.junit.JUnitTestTask.call(JUnitTestTask.java:25) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.lang.Thread.run(Thread.java:834)
